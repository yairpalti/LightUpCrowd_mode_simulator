<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flashlight Mode Simulator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.development.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.development.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        .device-grid {
            display: grid;
            gap: 2px;
            padding: 16px;
            background-color: #000;
            border-radius: 8px;
            border: 2px solid #4b5563;
            max-width: 600px;
            margin: 0 auto;
        }
        
        .device {
            aspect-ratio: 1;
            border-radius: 2px;
            transition: all 0.15s ease;
            border: 1px solid;
        }
        
        .device.on {
            background-color: #fde047;
            border-color: #facc15;
            box-shadow: 0 0 8px rgba(255, 255, 0, 0.8);
        }
        
        .device.off {
            background-color: #374151;
            border-color: #4b5563;
        }
        
        .control-panel {
            background-color: #1f2937;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        .parameter-panel {
            background-color: #1f2937;
            border-radius: 8px;
            padding: 16px;
        }
        
        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
        }
        
        .status-running {
            background-color: rgba(34, 197, 94, 0.2);
            color: #22c55e;
        }
        
        .status-stopped {
            background-color: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }
        
        .progress-bar {
            width: 100%;
            height: 12px;
            background-color: #374151;
            border-radius: 6px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background-color: #fbbf24;
            transition: width 0.1s ease;
        }
        
        .timeline-event {
            display: flex;
            justify-content: between;
            align-items: center;
            padding: 8px;
            background-color: #374151;
            border-radius: 4px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const FlashlightModeSimulator = () => {
            const [gridSize, setGridSize] = useState({ width: 15, height: 10 });
            const [devices, setDevices] = useState([]);
            const [currentMode, setCurrentMode] = useState('off');
            const [isRunning, setIsRunning] = useState(false);
            const [simulationSpeed, setSimulationSpeed] = useState(1);
            const [isReplayMode, setIsReplayMode] = useState(true);
            const [currentCycle, setCurrentCycle] = useState(0);
            const [currentTime, setCurrentTime] = useState(0);
            const [championsStartTime, setChampionsStartTime] = useState(null);
            const [currentPatternIndex, setCurrentPatternIndex] = useState(-1);
            
            const [modeParams, setModeParams] = useState({
                blink: { interval: 500 },
                twinkle: { minInterval: 100, maxInterval: 400 },
                grow: { steps: 50, stepDuration: 100 },
                reduce: { steps: 50, stepDuration: 100 },
                morse: { sentence: 'SOS', dotTime: 200 },
                wave: { speed: 100, direction: 'left_to_right' },
                heartbeat: { interval: 1200, beatDuration: 150 },
                ripple: { speed: 80, centerX: 7, centerY: 5 },
                strobe: { frequency: 100, burstCount: 10 },
                countdown: { from: 5, interval: 1000 },
                breathing: { cycle: 4000, intensity: 0.3 },
                champions: { 
                    syncOffset: 0,
                    brightness: 1.0
                }
            });

            const timersRef = useRef([]);
            const timeUpdateRef = useRef(null);

            // Musical pattern for "We Are The Champions" - lights sync with melody
            const championsPattern = [
                // Intro
                { time: 0, lights: false, duration: 2.0, section: "Silence - intro build" },
                { time: 2, lights: true, duration: 0.5, section: "Piano starts" },
                { time: 2.5, lights: false, duration: 1.5, section: "Piano phrase" },
                { time: 4, lights: true, duration: 0.5, section: "Piano accent" },
                { time: 4.5, lights: false, duration: 1.5, section: "Piano continues" },
                { time: 6, lights: true, duration: 0.5, section: "Piano phrase" },
                { time: 6.5, lights: false, duration: 1.5, section: "Piano" },
                { time: 8, lights: true, duration: 1.0, section: "Building" },
                { time: 9, lights: false, duration: 1.0, section: "Rest" },
                { time: 10, lights: true, duration: 0.5, section: "Build continues" },
                { time: 10.5, lights: false, duration: 1.5, section: "Preparing for vocals" },
                
                // First verse
                { time: 12, lights: true, duration: 2.0, section: "First verse starts" },
                { time: 14, lights: false, duration: 1.0, section: "pause" },
                { time: 15, lights: true, duration: 2.0, section: "Verse continues" },
                { time: 17, lights: false, duration: 1.0, section: "pause" },
                { time: 18, lights: true, duration: 2.0, section: "Vocal line" },
                { time: 20, lights: false, duration: 1.0, section: "pause" },
                { time: 21, lights: true, duration: 2.0, section: "Verse buildup" },
                { time: 23, lights: false, duration: 1.0, section: "pause" },
                
                // Verse continues
                { time: 24, lights: true, duration: 2.0, section: "Second part of verse" },
                { time: 26, lights: false, duration: 1.0, section: "pause" },
                { time: 27, lights: true, duration: 2.0, section: "Building tension" },
                { time: 29, lights: false, duration: 1.0, section: "pause" },
                { time: 30, lights: true, duration: 2.0, section: "Verse climax" },
                { time: 32, lights: false, duration: 0.5, section: "pause" },
                { time: 32.5, lights: true, duration: 2.0, section: "Building to chorus" },
                { time: 34.5, lights: false, duration: 1.0, section: "pause" },
                { time: 35.5, lights: true, duration: 1.5, section: "Pre-chorus" },
                { time: 37, lights: false, duration: 1.0, section: "building to chorus" },
                
                // Pre-chorus build
                { time: 38, lights: true, duration: 0.5, section: "Building intensity" },
                { time: 38.5, lights: false, duration: 0.5, section: "Quick flash" },
                { time: 39, lights: true, duration: 0.5, section: "Building more" },
                { time: 39.5, lights: false, duration: 0.5, section: "Quick pause" },
                { time: 40, lights: true, duration: 2.0, section: "Big build" },
                { time: 42, lights: false, duration: 1.0, section: "dramatic pause" },
                
                // CHORUS - The big moment
                { time: 43, lights: true, duration: 3.0, section: "🎵 MAIN CHORUS" },
                { time: 46, lights: false, duration: 0.5, section: "Brief pause" },
                { time: 46.5, lights: true, duration: 2.5, section: "🎵 CHORUS CONTINUES" },
                { time: 49, lights: false, duration: 1.0, section: "pause" },
                { time: 50, lights: true, duration: 2.0, section: "And we'll keep on fighting" },
                { time: 52, lights: false, duration: 0.5, section: "pause" },
                { time: 52.5, lights: true, duration: 2.0, section: "till the end" },
                { time: 54.5, lights: false, duration: 1.5, section: "dramatic pause" },
                { time: 56, lights: true, duration: 3.0, section: "🎵 CHAMPIONS AGAIN" },
                { time: 59, lights: false, duration: 1.0, section: "pause" },
                { time: 60, lights: true, duration: 3.0, section: "🎵 BIG FINISH" },
                { time: 63, lights: false, duration: 1.0, section: "Final pause" },
                { time: 64, lights: true, duration: 4.0, section: "🎵 CHAMPIONS OF THE WORLD" },
                { time: 68, lights: false, duration: 2.0, section: "End of chorus" },
                
                // Continue pattern through song...
                { time: 70, lights: true, duration: 2.0, section: "Second verse begins" },
                { time: 72, lights: false, duration: 1.0, section: "pause" },
                { time: 73, lights: true, duration: 2.0, section: "Verse continues" },
                { time: 75, lights: false, duration: 1.0, section: "pause" },
                { time: 76, lights: true, duration: 2.0, section: "Building again" },
                { time: 78, lights: false, duration: 0.5, section: "Quick pause" },
                { time: 78.5, lights: true, duration: 2.0, section: "Verse climax" },
                { time: 80.5, lights: false, duration: 1.0, section: "pause" },
                { time: 81.5, lights: true, duration: 1.5, section: "Pre-final chorus" },
                { time: 83, lights: false, duration: 2.0, section: "Building tension" },
                
                // Final section
                { time: 85, lights: true, duration: 2.0, section: "Final build begins" },
                { time: 87, lights: false, duration: 1.0, section: "pause" },
                { time: 88, lights: true, duration: 2.0, section: "Getting ready" },
                { time: 90, lights: false, duration: 1.0, section: "pause" },
                { time: 91, lights: true, duration: 2.0, section: "Almost there" },
                { time: 93, lights: false, duration: 0.5, section: "Quick pause" },
                { time: 93.5, lights: true, duration: 1.5, section: "Final preparation" },
                { time: 95, lights: false, duration: 1.0, section: "Last pause" },
                { time: 96, lights: true, duration: 2.0, section: "Final chorus building" },
                
                // FINAL CHORUS - Even more dramatic
                { time: 98, lights: true, duration: 3.5, section: "🎵 FINAL CHAMPIONS" },
                { time: 101.5, lights: false, duration: 0.5, section: "Brief pause" },
                { time: 102, lights: true, duration: 3.0, section: "🎵 BIGGEST MOMENT" },
                { time: 105, lights: false, duration: 1.0, section: "pause" },
                { time: 106, lights: true, duration: 2.0, section: "Keep on fighting" },
                { time: 108, lights: false, duration: 0.5, section: "pause" },
                { time: 108.5, lights: true, duration: 2.5, section: "Till the end" },
                { time: 111, lights: false, duration: 1.0, section: "Big dramatic pause" },
                { time: 112, lights: true, duration: 4.0, section: "🎵 ULTIMATE CHAMPIONS" },
                { time: 116, lights: false, duration: 1.0, section: "pause" },
                { time: 117, lights: true, duration: 4.0, section: "🎵 FINAL CHAMPIONS" },
                { time: 121, lights: false, duration: 1.0, section: "No time for losers" },
                { time: 122, lights: true, duration: 5.0, section: "🎵 CHAMPIONS OF THE WORLD" },
                { time: 127, lights: false, duration: 3.0, section: "Song ending" },
                
                // Outro
                { time: 130, lights: true, duration: 1.0, section: "Final flourish" },
                { time: 131, lights: false, duration: 1.0, section: "pause" },
                { time: 132, lights: true, duration: 2.0, section: "Last champions" },
                { time: 134, lights: false, duration: 5.0, section: "Fade to end" }
            ];

            // Initialize devices
            useEffect(() => {
                const newDevices = [];
                for (let y = 0; y < gridSize.height; y++) {
                    for (let x = 0; x < gridSize.width; x++) {
                        newDevices.push({
                            id: `${x}-${y}`,
                            x,
                            y,
                            isOn: false,
                            assignedStep: Math.floor(Math.random() * 100) + 1,
                            section: Math.floor((x + y) / 3) % 4
                        });
                    }
                }
                setDevices(newDevices);
            }, [gridSize]);

            // Clear all timers
            const clearTimers = () => {
                timersRef.current.forEach(timer => clearTimeout(timer));
                timersRef.current = [];
                if (timeUpdateRef.current) {
                    clearInterval(timeUpdateRef.current);
                    timeUpdateRef.current = null;
                }
            };

            // Safe timeout
            const safeTimeout = (callback, delay) => {
                const timer = setTimeout(callback, delay);
                timersRef.current.push(timer);
                return timer;
            };

            // Turn all devices on/off
            const setAllDevices = (state) => {
                setDevices(prev => prev.map(device => ({ 
                    ...device, 
                    isOn: state 
                })));
            };

            // Update specific device
            const updateDevice = (deviceId, isOn) => {
                setDevices(prev => prev.map(device => 
                    device.id === deviceId ? { ...device, isOn } : device
                ));
            };

            // Start selected mode with replay capability
            const startMode = () => {
                clearTimers();
                
                // Helper function to schedule next cycle
                const scheduleNextCycle = (delay = 2000) => {
                    if (isReplayMode && isRunning) {
                        safeTimeout(() => {
                            setCurrentCycle(prev => prev + 1);
                            startMode();
                        }, delay / simulationSpeed);
                    }
                };
                
                switch (currentMode) {
                    case 'off':
                        setAllDevices(false);
                        if (isReplayMode) {
                            scheduleNextCycle(1000);
                        }
                        break;
                        
                    case 'on':
                        setAllDevices(true);
                        if (isReplayMode) {
                            scheduleNextCycle(1000);
                        }
                        break;

                    case 'champions':
                        // Execute "We Are The Champions" melody-synced pattern
                        setAllDevices(false);
                        setChampionsStartTime(Date.now());
                        setCurrentTime(0);
                        setCurrentPatternIndex(-1);
                        
                        // Start time tracking
                        timeUpdateRef.current = setInterval(() => {
                            if (!isRunning || !championsStartTime) return;
                            const elapsed = (Date.now() - championsStartTime) / 1000 / simulationSpeed;
                            setCurrentTime(elapsed);
                            
                            // Find current pattern
                            const activePattern = championsPattern.findIndex((pattern, index) => {
                                const nextPattern = championsPattern[index + 1];
                                return elapsed >= pattern.time && (!nextPattern || elapsed < nextPattern.time);
                            });
                            setCurrentPatternIndex(activePattern);
                        }, 100);
                        
                        let patternIndex = 0;
                        
                        const executeChampionsPattern = () => {
                            if (!isRunning || patternIndex >= championsPattern.length) {
                                if (isReplayMode && patternIndex >= championsPattern.length) {
                                    scheduleNextCycle(3000);
                                }
                                return;
                            }
                            
                            const currentPattern = championsPattern[patternIndex];
                            const nextPattern = championsPattern[patternIndex + 1];
                            
                            // Calculate when this pattern should execute (adjusted for simulation speed)
                            const executeTime = (currentPattern.time * 1000) / simulationSpeed;
                            
                            // Set lights according to pattern
                            safeTimeout(() => {
                                if (!isRunning) return;
                                setAllDevices(currentPattern.lights);
                            }, executeTime);
                            
                            // Move to next pattern
                            patternIndex++;
                            
                            // Schedule next pattern execution
                            if (nextPattern) {
                                const nextExecuteTime = (nextPattern.time * 1000) / simulationSpeed;
                                safeTimeout(executeChampionsPattern, nextExecuteTime - executeTime);
                            } else if (isReplayMode) {
                                // All patterns complete, schedule replay
                                const totalSongTime = (championsPattern[championsPattern.length - 1].time + 
                                                     championsPattern[championsPattern.length - 1].duration) * 1000;
                                safeTimeout(() => {
                                    scheduleNextCycle(2000);
                                }, (totalSongTime / simulationSpeed) - executeTime);
                            }
                        };
                        
                        executeChampionsPattern();
                        break;
                        
                    case 'blink':
                        let blinkOn = false;
                        let blinkCount = 0;
                        const maxBlinks = isReplayMode ? 10 : Infinity;
                        
                        const blinkLoop = () => {
                            if (!isRunning) return;
                            if (isReplayMode && blinkCount >= maxBlinks) {
                                scheduleNextCycle();
                                return;
                            }
                            
                            blinkOn = !blinkOn;
                            setAllDevices(blinkOn);
                            blinkCount++;
                            safeTimeout(blinkLoop, modeParams.blink.interval / simulationSpeed);
                        };
                        blinkLoop();
                        break;
                        
                    case 'twinkle':
                        const twinkleStartTime = Date.now();
                        const twinkleDuration = isReplayMode ? 5000 : Infinity;
                        
                        devices.forEach(device => {
                            const twinkleDevice = () => {
                                if (!isRunning) return;
                                if (isReplayMode && (Date.now() - twinkleStartTime) > twinkleDuration) {
                                    return;
                                }
                                
                                const shouldBeOn = Math.random() > 0.7;
                                updateDevice(device.id, shouldBeOn);
                                const delay = modeParams.twinkle.minInterval + 
                                    Math.random() * (modeParams.twinkle.maxInterval - modeParams.twinkle.minInterval);
                                safeTimeout(twinkleDevice, delay / simulationSpeed);
                            };
                            safeTimeout(twinkleDevice, Math.random() * 1000);
                        });
                        
                        if (isReplayMode) {
                            safeTimeout(() => {
                                setAllDevices(false);
                                scheduleNextCycle();
                            }, twinkleDuration / simulationSpeed);
                        }
                        break;
                        
                    case 'grow':
                        setAllDevices(false);
                        let growStep = 0;
                        const growLoop = () => {
                            if (!isRunning || growStep >= modeParams.grow.steps) {
                                if (isReplayMode && growStep >= modeParams.grow.steps) {
                                    scheduleNextCycle();
                                }
                                return;
                            }
                            growStep++;
                            setDevices(prev => prev.map(device => ({
                                ...device,
                                isOn: device.assignedStep <= growStep
                            })));
                            safeTimeout(growLoop, modeParams.grow.stepDuration / simulationSpeed);
                        };
                        safeTimeout(growLoop, 100);
                        break;
                        
                    case 'morse':
                        const morseMap = {
                            'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.',
                            'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---',
                            'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---',
                            'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-',
                            'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--',
                            'Z': '--..', ' ': ' '
                        };
                        
                        setAllDevices(false);
                        let delay = 0;
                        const { sentence, dotTime } = modeParams.morse;
                        let maxDelay = 0;
                        
                        sentence.toUpperCase().split('').forEach(char => {
                            if (char === ' ') {
                                delay += dotTime * 7;
                                return;
                            }
                            const morse = morseMap[char];
                            if (!morse) return;
                            
                            morse.split('').forEach(symbol => {
                                const duration = symbol === '.' ? dotTime : dotTime * 3;
                                safeTimeout(() => setAllDevices(true), delay / simulationSpeed);
                                safeTimeout(() => setAllDevices(false), (delay + duration) / simulationSpeed);
                                delay += duration + dotTime;
                                maxDelay = Math.max(maxDelay, delay + duration);
                            });
                            delay += dotTime * 2;
                            maxDelay = Math.max(maxDelay, delay);
                        });
                        
                        if (isReplayMode) {
                            safeTimeout(() => {
                                scheduleNextCycle();
                            }, (maxDelay + 1000) / simulationSpeed);
                        }
                        break;
                        
                    case 'wave':
                        setAllDevices(false);
                        let maxWaveDelay = 0;
                        
                        devices.forEach(device => {
                            let waveDelay = 0;
                            switch (modeParams.wave.direction) {
                                case 'left_to_right':
                                    waveDelay = device.x * modeParams.wave.speed;
                                    break;
                                case 'right_to_left':
                                    waveDelay = (gridSize.width - device.x - 1) * modeParams.wave.speed;
                                    break;
                                case 'top_to_bottom':
                                    waveDelay = device.y * modeParams.wave.speed;
                                    break;
                                case 'bottom_to_top':
                                    waveDelay = (gridSize.height - device.y - 1) * modeParams.wave.speed;
                                    break;
                            }
                            
                            maxWaveDelay = Math.max(maxWaveDelay, waveDelay + 300);
                            
                            safeTimeout(() => {
                                updateDevice(device.id, true);
                                safeTimeout(() => updateDevice(device.id, false), 300 / simulationSpeed);
                            }, waveDelay / simulationSpeed);
                        });
                        
                        if (isReplayMode) {
                            safeTimeout(() => {
                                scheduleNextCycle();
                            }, (maxWaveDelay + 500) / simulationSpeed);
                        }
                        break;
                        
                    case 'heartbeat':
                        const performHeartbeat = () => {
                            if (!isRunning) return;
                            
                            // First beat
                            setAllDevices(true);
                            safeTimeout(() => {
                                setAllDevices(false);
                                // Short pause
                                safeTimeout(() => {
                                    // Second beat
                                    setAllDevices(true);
                                    safeTimeout(() => {
                                        setAllDevices(false);
                                        // Long pause before next heartbeat
                                        const nextHeartbeatDelay = (modeParams.heartbeat.interval - modeParams.heartbeat.beatDuration * 3) / simulationSpeed;
                                        safeTimeout(performHeartbeat, nextHeartbeatDelay);
                                    }, modeParams.heartbeat.beatDuration / simulationSpeed);
                                }, modeParams.heartbeat.beatDuration * 0.5 / simulationSpeed);
                            }, modeParams.heartbeat.beatDuration / simulationSpeed);
                        };
                        
                        setAllDevices(false);
                        performHeartbeat();
                        break;
                        
                    case 'ripple':
                        setAllDevices(false);
                        const { centerX, centerY, speed } = modeParams.ripple;
                        let maxRippleDelay = 0;
                        
                        devices.forEach(device => {
                            const distance = Math.sqrt(
                                Math.pow(device.x - centerX, 2) + Math.pow(device.y - centerY, 2)
                            );
                            const rippleDelay = distance * speed;
                            maxRippleDelay = Math.max(maxRippleDelay, rippleDelay + 300);
                            
                            safeTimeout(() => {
                                updateDevice(device.id, true);
                                safeTimeout(() => updateDevice(device.id, false), 300 / simulationSpeed);
                            }, rippleDelay / simulationSpeed);
                        });
                        
                        if (isReplayMode) {
                            safeTimeout(() => {
                                scheduleNextCycle();
                            }, (maxRippleDelay + 500) / simulationSpeed);
                        }
                        break;
                        
                    case 'strobe':
                        setAllDevices(false);
                        let strobeCount = 0;
                        const strobeLoop = () => {
                            if (!isRunning || strobeCount >= modeParams.strobe.burstCount) {
                                if (isReplayMode && strobeCount >= modeParams.strobe.burstCount) {
                                    scheduleNextCycle();
                                }
                                return;
                            }
                            setAllDevices(true);
                            safeTimeout(() => {
                                setAllDevices(false);
                                strobeCount++;
                                if (strobeCount < modeParams.strobe.burstCount) {
                                    safeTimeout(strobeLoop, modeParams.strobe.frequency / simulationSpeed);
                                } else if (isReplayMode) {
                                    scheduleNextCycle();
                                }
                            }, (modeParams.strobe.frequency * 0.3) / simulationSpeed);
                        };
                        strobeLoop();
                        break;
                        
                    case 'breathing':
                        let breathStep = 0;
                        const breathStartTime = Date.now();
                        const breathDuration = isReplayMode ? modeParams.breathing.cycle * 3 : Infinity;
                        
                        const breathLoop = () => {
                            if (!isRunning) return;
                            if (isReplayMode && (Date.now() - breathStartTime) > breathDuration) {
                                setAllDevices(false);
                                scheduleNextCycle();
                                return;
                            }
                            
                            const cycle = modeParams.breathing.cycle / simulationSpeed;
                            const steps = 100;
                            const cyclePos = breathStep % (steps * 2);
                            
                            let intensity;
                            if (cyclePos < steps) {
                                intensity = (cyclePos / steps) * modeParams.breathing.intensity;
                            } else {
                                intensity = (1 - ((cyclePos - steps) / steps)) * modeParams.breathing.intensity;
                            }
                            
                            setDevices(prev => prev.map(device => ({
                                ...device,
                                isOn: Math.random() < intensity
                            })));
                            
                            breathStep++;
                            safeTimeout(breathLoop, cycle / (steps * 2));
                        };
                        breathLoop();
                        break;
                        
                    default:
                        setAllDevices(false);
                }
            };

            // Start simulation
            const startSimulation = () => {
                setIsRunning(true);
                setCurrentCycle(0);
                setCurrentTime(0);
                setChampionsStartTime(null);
                setCurrentPatternIndex(-1);
            };

            // Stop simulation
            const stopSimulation = () => {
                setIsRunning(false);
                clearTimers();
                setAllDevices(false);
                setCurrentCycle(0);
                setCurrentTime(0);
                setChampionsStartTime(null);
                setCurrentPatternIndex(-1);
            };

            // Effect to start mode when running
            useEffect(() => {
                if (isRunning) {
                    startMode();
                }
            }, [isRunning]);

            // Helper function to format time as MM:SS
            const formatTime = (seconds) => {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            };

            // Update mode parameter
            const updateModeParam = (mode, param, value) => {
                setModeParams(prev => ({
                    ...prev,
                    [mode]: { ...prev[mode], [param]: value }
                }));
            };

            // Cleanup on unmount
            useEffect(() => {
                return () => clearTimers();
            }, []);

            return (
                <div className="p-6 bg-gray-900 text-white min-h-screen">
                    <h1 className="text-3xl font-bold mb-6 text-center">Flashlight Mode Simulator</h1>
                    
                    <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                        {/* Controls */}
                        <div className="space-y-4">
                            <div className="control-panel">
                                <h2 className="text-xl font-semibold mb-3">Controls</h2>
                                
                                <div className="space-y-3">
                                    <div>
                                        <label className="block text-sm font-medium mb-1">Mode</label>
                                        <select 
                                            value={currentMode} 
                                            onChange={(e) => setCurrentMode(e.target.value)}
                                            className="w-full p-2 bg-gray-700 rounded border border-gray-600 text-white"
                                            disabled={isRunning}
                                        >
                                            <option value="off">OFF</option>
                                            <option value="on">ON</option>
                                            <option value="champions">🎵 CHAMPIONS</option>
                                            <option value="blink">BLINK</option>
                                            <option value="twinkle">TWINKLE</option>
                                            <option value="grow">GROW</option>
                                            <option value="morse">MORSE</option>
                                            <option value="wave">WAVE</option>
                                            <option value="heartbeat">HEARTBEAT</option>
                                            <option value="ripple">RIPPLE</option>
                                            <option value="strobe">STROBE</option>
                                            <option value="breathing">BREATHING</option>
                                        </select>
                                    </div>
                                    
                                    <div>
                                        <label className="block text-sm font-medium mb-1">
                                            Speed: {simulationSpeed}x
                                        </label>
                                        <input
                                            type="range"
                                            min="0.1"
                                            max="5"
                                            step="0.1"
                                            value={simulationSpeed}
                                            onChange={(e) => setSimulationSpeed(parseFloat(e.target.value))}
                                            className="w-full"
                                            disabled={isRunning}
                                        />
                                    </div>
                                    
                                    <div>
                                        <label className="flex items-center space-x-2">
                                            <input
                                                type="checkbox"
                                                checked={isReplayMode}
                                                onChange={(e) => setIsReplayMode(e.target.checked)}
                                                className="rounded"
                                                disabled={isRunning}
                                            />
                                            <span className="text-sm font-medium">Replay Mode (Loop continuously)</span>
                                        </label>
                                    </div>
                                    
                                    <div className="flex gap-2">
                                        <button
                                            onClick={startSimulation}
                                            disabled={isRunning}
                                            className="flex-1 bg-green-600 hover:bg-green-700 disabled:bg-gray-600 px-4 py-2 rounded font-medium transition-colors"
                                        >
                                            Start
                                        </button>
                                        <button
                                            onClick={stopSimulation}
                                            className="flex-1 bg-red-600 hover:bg-red-700 px-4 py-2 rounded font-medium transition-colors"
                                        >
                                            Stop
                                        </button>
                                    </div>
                                    
                                    <div className="text-center">
                                        <div className={`status-indicator ${isRunning ? 'status-running' : 'status-stopped'}`}>
                                            {isRunning ? '🟢 Running' : '🔴 Stopped'}
                                        </div>
                                        {isRunning && isReplayMode && (
                                            <div className="text-blue-400 mt-2 text-sm">
                                                🔄 Cycle #{currentCycle + 1} • Replay Mode
                                            </div>
                                        )}
                                        {isRunning && !isReplayMode && (
                                            <div className="text-yellow-400 mt-2 text-sm">
                                                ▶️ Single Play Mode
                                            </div>
                                        )}
                                    </div>
                                </div>
                            </div>

                            {/* Mode Parameters */}
                            <div className="parameter-panel">
                                <h2 className="text-xl font-semibold mb-3">Parameters</h2>
                                
                                {currentMode === 'champions' && (
                                    <div className="space-y-3">
                                        <div>
                                            <label className="block text-sm font-medium mb-1">
                                                Sync Offset: {modeParams.champions.syncOffset}s
                                            </label>
                                            <input
                                                type="range"
                                                min="-5"
                                                max="5"
                                                step="0.1"
                                                value={modeParams.champions.syncOffset}
                                                onChange={(e) => updateModeParam('champions', 'syncOffset', parseFloat(e.target.value))}
                                                className="w-full"
                                                disabled={isRunning}
                                            />
                                            <div className="text-xs text-gray-400 mt-1">
                                                Adjust timing to sync with your audio playback
                                            </div>
                                        </div>
                                        <div>
                                            <label className="block text-sm font-medium mb-1">
                                                Brightness: {modeParams.champions.brightness}
                                            </label>
                                            <input
                                                type="range"
                                                min="0.1"
                                                max="1.0"
                                                step="0.1"
                                                value={modeParams.champions.brightness}
                                                onChange={(e) => updateModeParam('champions', 'brightness', parseFloat(e.target.value))}
                                                className="w-full"
                                                disabled={isRunning}
                                            />
                                        </div>
                                        <div className="text-xs text-gray-400 mt-2 p-2 bg-gray-700 rounded">
                                            🎵 <strong>Instructions:</strong> Start this simulator, then immediately play "We Are The Champions" by Queen. 
                                            The lights will sync with the melody. Use sync offset if timing is off.
                                        </div>
                                        <div className="text-xs text-green-400 mt-1">
                                            ⏱️ Pattern Duration: 2 minutes 20 seconds
                                        </div>
                                    </div>
                                )}

                                {currentMode === 'blink' && (
                                    <div>
                                        <label className="block text-sm font-medium mb-1">
                                            Interval: {modeParams.blink.interval}ms
                                        </label>
                                        <input
                                            type="range"
                                            min="50"
                                            max="2000"
                                            value={modeParams.blink.interval}
                                            onChange={(e) => updateModeParam('blink', 'interval', parseInt(e.target.value))}
                                            className="w-full"
                                            disabled={isRunning}
                                        />
                                    </div>
                                )}

                                {currentMode === 'heartbeat' && (
                                    <div className="space-y-2">
                                        <div>
                                            <label className="block text-sm font-medium mb-1">
                                                Beat Interval: {modeParams.heartbeat.interval}ms
                                            </label>
                                            <input
                                                type="range"
                                                min="800"
                                                max="3000"
                                                value={modeParams.heartbeat.interval}
                                                onChange={(e) => updateModeParam('heartbeat', 'interval', parseInt(e.target.value))}
                                                className="w-full"
                                                disabled={isRunning}
                                            />
                                        </div>
                                        <div>
                                            <label className="block text-sm font-medium mb-1">
                                                Beat Duration: {modeParams.heartbeat.beatDuration}ms
                                            </label>
                                            <input
                                                type="range"
                                                min="50"
                                                max="300"
                                                value={modeParams.heartbeat.beatDuration}
                                                onChange={(e) => updateModeParam('heartbeat', 'beatDuration', parseInt(e.target.value))}
                                                className="w-full"
                                                disabled={isRunning}
                                            />
                                        </div>
                                    </div>
                                )}

                                {currentMode === 'wave' && (
                                    <div className="space-y-2">
                                        <div>
                                            <label className="block text-sm font-medium mb-1">Direction</label>
                                            <select
                                                value={modeParams.wave.direction}
                                                onChange={(e) => updateModeParam('wave', 'direction', e.target.value)}
                                                className="w-full p-2 bg-gray-700 rounded border border-gray-600 text-white"
                                                disabled={isRunning}
                                            >
                                                <option value="left_to_right">Left to Right</option>
                                                <option value="right_to_left">Right to Left</option>
                                                <option value="top_to_bottom">Top to Bottom</option>
                                                <option value="bottom_to_top">Bottom to Top</option>
                                            </select>
                                        </div>
                                        <div>
                                            <label className="block text-sm font-medium mb-1">
                                                Speed: {modeParams.wave.speed}ms
                                            </label>
                                            <input
                                                type="range"
                                                min="10"
                                                max="500"
                                                value={modeParams.wave.speed}
                                                onChange={(e) => updateModeParam('wave', 'speed', parseInt(e.target.value))}
                                                className="w-full"
                                                disabled={isRunning}
                                            />
                                        </div>
                                    </div>
                                )}

                                {currentMode === 'morse' && (
                                    <div className="space-y-2">
                                        <div>
                                            <label className="block text-sm font-medium mb-1">Message</label>
                                            <input
                                                type="text"
                                                value={modeParams.morse.sentence}
                                                onChange={(e) => updateModeParam('morse', 'sentence', e.target.value)}
                                                className="w-full p-2 bg-gray-700 rounded border border-gray-600 text-white"
                                                placeholder="Enter text..."
                                                disabled={isRunning}
                                            />
                                        </div>
                                        <div>
                                            <label className="block text-sm font-medium mb-1">
                                                Dot Time: {modeParams.morse.dotTime}ms
                                            </label>
                                            <input
                                                type="range"
                                                min="50"
                                                max="1000"
                                                value={modeParams.morse.dotTime}
                                                onChange={(e) => updateModeParam('morse', 'dotTime', parseInt(e.target.value))}
                                                className="w-full"
                                                disabled={isRunning}
                                            />
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>

                        {/* Visualization */}
                        <div className="lg:col-span-2">
                            <div className="control-panel">
                                <h2 className="text-xl font-semibold mb-3">
                                    {currentMode.toUpperCase()} Mode
                                    {currentMode === 'champions' && <span className="text-yellow-400 ml-2">♪ Musical Pattern</span>}
                                    {isRunning && <span className="text-green-400 ml-2">● RUNNING</span>}
                                    {isRunning && isReplayMode && (
                                        <span className="text-blue-400 ml-2">🔄 REPLAY</span>
                                    )}
                                </h2>
                                
                                <div 
                                    className="device-grid"
                                    style={{
                                        gridTemplateColumns: `repeat(${gridSize.width}, 1fr)`,
                                    }}
                                >
                                    {devices.map(device => (
                                        <div
                                            key={device.id}
                                            className={`device ${device.isOn ? 'on' : 'off'}`}
                                        />
                                    ))}
                                </div>
                                
                                <div className="mt-4 text-sm text-gray-400 text-center">
                                    {devices.length} devices • {devices.filter(d => d.isOn).length} active
                                    {isRunning && isReplayMode && (
                                        <div className="mt-1 text-blue-400">
                                            Cycle #{currentCycle + 1} • Will restart automatically
                                        </div>
                                    )}
                                </div>
                            </div>

                            {/* Champions Timeline Display */}
                            {currentMode === 'champions' && isRunning && (
                                <div className="mt-4 control-panel">
                                    <h3 className="font-semibold mb-3 text-center">🎵 Song Timeline & Current Position</h3>
                                    
                                    {/* Time Display */}
                                    <div className="text-center mb-4">
                                        <div className="text-2xl font-mono text-yellow-400">
                                            {formatTime(currentTime)} / {formatTime(140)}
                                        </div>
                                        <div className="text-sm text-gray-400">
                                            Current Position in Song
                                        </div>
                                    </div>
                                    
                                    {/* Progress Bar */}
                                    <div className="mb-4">
                                        <div className="progress-bar">
                                            <div 
                                                className="progress-fill"
                                                style={{ width: `${Math.min((currentTime / 140) * 100, 100)}%` }}
                                            ></div>
                                        </div>
                                    </div>
                                    
                                    {/* Current Action Display */}
                                    {currentPatternIndex >= 0 && currentPatternIndex < championsPattern.length && (
                                        <div className="text-center p-3 bg-gray-700 rounded-lg">
                                            <div className="font-semibold text-lg">
                                                {championsPattern[currentPatternIndex].lights ? 
                                                    '💡 LIGHTS ON' : '🔴 LIGHTS OFF'}
                                            </div>
                                            <div className="text-sm text-yellow-300 mt-1 font-medium">
                                                🎵 {championsPattern[currentPatternIndex].section}
                                            </div>
                                            <div className="text-xs text-gray-400 mt-1">
                                                Duration: {championsPattern[currentPatternIndex].duration}s
                                            </div>
                                        </div>
                                    )}
                                    
                                    {/* Upcoming Events */}
                                    <div className="mt-4">
                                        <h4 className="font-medium mb-2 text-center">Next Events:</h4>
                                        <div className="space-y-1 max-h-32 overflow-y-auto">
                                            {championsPattern
                                                .filter(pattern => pattern.time > currentTime && pattern.time <= currentTime + 15)
                                                .slice(0, 5)
                                                .map((pattern, index) => (
                                                    <div key={index} className="timeline-event">
                                                        <span className="text-gray-300 flex-1">{pattern.section}</span>
                                                        <span className="text-yellow-400 font-mono">
                                                            {formatTime(pattern.time)} {pattern.lights ? '💡' : '🔴'}
                                                        </span>
                                                    </div>
                                                ))
                                            }
                                        </div>
                                    </div>
                                    
                                    {/* Instructions */}
                                    <div className="mt-4 p-2 bg-blue-900/30 rounded border border-blue-500/30">
                                        <div className="text-xs text-blue-300 text-center">
                                            🎵 <strong>Play "We Are The Champions" by Queen now!</strong><br/>
                                            Watch the timeline to see how lights sync with the music<br/>
                                            <span className="text-green-300">🎤 Karaoke-style: Current song section shows above</span>
                                        </div>
                                    </div>
                                </div>
                            )}

                            {/* Mode Descriptions */}
                            <div className="mt-4 control-panel">
                                <h3 className="font-semibold mb-2">Mode Descriptions</h3>
                                <div className="text-sm text-gray-300 space-y-1">
                                    <div><strong>🎵 CHAMPIONS:</strong> All lights turn on/off together following the melody of the famous Queen song. Start the simulator then play the song!</div>
                                    <div><strong>HEARTBEAT:</strong> Double-beat pulse pattern (lub-dub)</div>
                                    <div><strong>WAVE:</strong> Sweeping effect across the crowd</div>
                                    <div><strong>RIPPLE:</strong> Concentric circles from center</div>
                                    <div><strong>STROBE:</strong> Rapid synchronized flashing</div>
                                    <div><strong>MORSE:</strong> Morse code transmission</div>
                                    <div><strong>GROW:</strong> Progressive activation</div>
                                    <div><strong>TWINKLE:</strong> Random sparkle effect</div>
                                    <div><strong>BLINK:</strong> Regular on/off pattern</div>
                                    <div><strong>BREATHING:</strong> Gentle fade in/out like breathing</div>
                                </div>
                                
                                {currentMode === 'champions' && (
                                    <div className="mt-3 p-3 bg-yellow-900/30 rounded border border-yellow-500/30">
                                        <div className="text-sm text-yellow-200">
                                            <strong>🎵 HOW TO USE CHAMPIONS MODE:</strong>
                                            <div className="mt-2 text-xs space-y-1">
                                                <div>1. Click "Start" to begin the light pattern</div>
                                                <div>2. Immediately play "We Are The Champions" by Queen</div>
                                                <div>3. Watch the lights sync with the melody and vocals</div>
                                                <div>4. Adjust "Sync Offset" if timing seems off</div>
                                                <div>5. Perfect for concerts, sports victories, or celebrations!</div>
                                            </div>
                                        </div>
                                    </div>
                                )}
                                
                                {isReplayMode && (
                                    <div className="mt-3 p-2 bg-blue-900/30 rounded border border-blue-500/30">
                                        <div className="text-xs text-blue-300">
                                            <strong>🔄 REPLAY MODE ACTIVE:</strong> Modes will loop continuously with brief pauses between cycles.
                                            Perfect for testing how patterns look when repeated!
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        ReactDOM.render(<FlashlightModeSimulator />, document.getElementById('root'));